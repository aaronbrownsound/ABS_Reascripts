-- ReaScript Name: Build a self-contained action from a track-template (embedded)
-- Author: You
-- Version: 1.2
-- About: Prompts for a .RTrackTemplate in REAPER's TrackTemplates folder,
--        then writes a new Lua script that inserts its tracks (FX/settings/routing).

local r = reaper

-- Safe path join (Windows/macOS/Linux)
local function path_join(a, b)
  local sep = package.config:sub(1,1) -- directory separator
  if a:sub(-1) == sep then return a .. b end
  return a .. sep .. b
end

local function ensure_dir(path)
  -- Creates directory if missing. Returns true on success / already exists.
  local ok = r.RecursiveCreateDirectory(path, 0)
  return ok == 1 or ok == 2
end

local function read_file(path)
  local f = io.open(path, "rb")
  if not f then return nil, "Can't open file: "..tostring(path) end
  local content = f:read("*a")
  f:close()
  return content
end

local function split_track_chunks(template_text)
  local chunks = {}
  -- Grab each <TRACK ... > block; REAPER chunks end with a lone '>' line.
  for chunk in template_text:gmatch("<TRACK.-\n>") do
    table.insert(chunks, chunk)
  end
  return chunks
end

local function sanitize_filename(name)
  name = name:gsub("[^%w%-%._%s]", "_")
  name = name:gsub("%s+", "_")
  return name
end

do
  local res_path = r.GetResourcePath()
  local tpl_folder = path_join(res_path, "TrackTemplates")
  local scripts_folder = path_join(res_path, "Scripts")

  -- Make sure these folders exist (no-op if they already do)
  ensure_dir(tpl_folder)
  ensure_dir(scripts_folder)

  -- File picker defaults to TrackTemplates
  local ok1, tpl_path = r.GetUserFileNameForRead(
    tpl_folder,
    "Pick a .RTrackTemplate to embed (REAPER/TrackTemplates)",
    ".RTrackTemplate"
  )
  if not ok1 then return end

  local txt, err = read_file(tpl_path)
  if not txt then
    r.ShowMessageBox("Failed to read template:\n"..tostring(err), "Error", 0)
    return
  end

  local chunks = split_track_chunks(txt)
  if #chunks == 0 then
    r.ShowMessageBox("No <TRACK ... > chunks found in file.", "Error", 0)
    return
  end

  local tpl_name = tpl_path:match("([^/\\]+)%.RTrackTemplate$") or "Template_Action"
  local script_name = "InsertTemplate_" .. sanitize_filename(tpl_name) .. ".lua"
  local out_path = path_join(scripts_folder, script_name)

  -- Build the new script with embedded chunks (safe long-bracket strings)
  local header = [[
-- ReaScript Name: Insert "]]..tpl_name..[[" template (embedded)
-- Generated by: Build-a-Template-Action
-- Description: Inserts the embedded track template (FX/settings/routing) without reading an external file.

local r = reaper

local chunks = {
]]
  local body = {}
  for i, ch in ipairs(chunks) do
    body[#body+1] = ("  [==[%s]==],\n"):format(ch)
  end

  local footer = [[
}

r.Undo_BeginBlock()
r.PreventUIRefresh(1)

local start_idx = r.CountTracks(0)
for i, chunk in ipairs(chunks) do
  r.InsertTrackAtIndex(start_idx + (i - 1), true)
  local tr = r.GetTrack(0, start_idx + (i - 1))
  r.SetTrackStateChunk(tr, chunk, true)
end

r.TrackList_AdjustWindows(false)
r.UpdateArrange()
r.PreventUIRefresh(-1)
r.Undo_EndBlock('Insert embedded track template "]]..tpl_name..[["', -1)
]]

  local f = io.open(out_path, "wb")
  if not f then
    r.ShowMessageBox("Could not write file:\n"..out_path, "Error", 0)
    return
  end
  f:write(header .. table.concat(body) .. footer)
  f:close()

  r.ShowMessageBox(
    "Created action:\n" .. out_path ..
    "\n\nLoad it in Actions â†’ ReaScript: Load.",
    "Done", 0
  )
end

